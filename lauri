#!/usr/bin/env luajit
local VERSION = "v0.1"
local AURRPC = "https://aur.archlinux.org/rpc.php?v=3&type="

local AURFIELDS = {'ID', 'Name', 'PackageBaseID', 'PackageBase', 'Version', 
                   'CategoryID', 'Description', 'URL', 'URLPath', 'NumVotes', 
                   'OutOfDate', 'Maintainer', 'FirstSubmitted', 'LastModified',
                   'Depends', 'MakeDepends', 'CheckDepends', 'OptDepends',
                   'Conflicts', 'Provides', 'Replaces', 'Groups', 'License'}

package.path = "./lib/?.lua;?.lua;" .. package.path
local ffi=require("ffi")
local alpm=require("alpm")
local archive=require("archive")
local json=require("JSON")
local curl=require("curl")


local enum = {}
function enum.bor(a, b)
    return ffi.cast(ffi.typeof(a), 
      bit.bor(tonumber(a),tonumber(ffi.cast(ffi.typeof(a), b))))
end
function enum.band(a, b)
    return ffi.cast(ffi.typeof(a), 
      bit.band(tonumber(a), tonumber(ffi.cast(ffi.typeof(a), b))))
end
function enum.hasset(a, b)
    return enum.band(a, b) == b
end

function table.set(t) -- set of list
  local u = { }
  for _, v in ipairs(t) do u[v] = true end
  return u
end

function table.add(f, l)
  assert(l ~= nil)
  if type(f) ~= 'table' then return {l} end
  for _, v in ipairs(f) do
    if v == l then return f end
  end
  f[#f+1] = l
  return f
end

local aur = {}
function aur.geturl(curleasy, method, args)
  local m={multiinfo=2, info=1, search=1, msearch=1, suggest=1, ['suggest-pkgbase']=1}
  if m[method] and m[method] == 2  then
    local esc,i,v={}
    for i,v in ipairs(args) do
      esc[i]=curleasy:escape(v)
    end
    return AURRPC..method..'&arg[]='..table.concat(esc, '&arg[]=')
  elseif m[method] then
    return AURRPC..method..'&arg='..curleasy:escape(args)
  end
  return nil
end

local BaseTree = {}
BaseTree.__index = BaseTree
function BaseTree.new(t)
   t = t or {}
   return setmetatable(t, BaseTree)
end
setmetatable(BaseTree,{
    __call = function (tbl,arg)
       return tbl.new(arg)
    end,
})
function BaseTree:add(pkg)
    if self[pkg.PackageBase] == nil then self[pkg.PackageBase] = {} end
    table.add(self[pkg.PackageBase], pkg.Name)
end


curl.init(curl.CURL_GLOBAL_ALL)
errno=ffi.new("alpm_errno_t[1]")
pacman=alpm.Alpm.initialize('/', '/var/lib/pacman', errno)
dbs = {}
for l in io.lines("/etc/pacman.conf") do
    local s = l:match("^%s*%[%s*([^%]%s]*)%s*]%s*$")
    if s and s ~= 'options' then
        dbs[#dbs+1] = alpm.alpm_register_syncdb(pacman, s, 0)
    end
end

function wrap(str, limit, indent, indent1)
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  return indent1..str:gsub("(%s+)()(%S+)()",
                          function(sp, st, word, fi)
                            if fi-here > limit then
                              here = st - #indent
                              return "\n"..indent..word
                            end
                          end)
end
function infotext(label, text, xtra)
  local ind = "                 "
  label = label and ("%-14s : "):format(label) or ind
  return wrap(tostring(text), 78, ind..(xtra or ""), label)
end
function infotable(label, text)
  if label == "OptDepends" then 
    local r,i={infotext(label, text[1]  or "", "  ")}
    for i=2,#text do
      r[i] = infotext(nil, text[i], "  ")
    end
    return table.concat(r, "\n")
  end
  return infotext(label, table.concat(text, ', '))
end

function aur.getinfo(pkgs)
  local c = curl.Easy.init()
  local io = require"io"

  if type(pkgs) == 'table' then
    c:setopt("CURLOPT_URL", aur.geturl(c, "multiinfo", pkgs))
  else
    c:setopt("CURLOPT_URL", aur.geturl(c, "info", pkgs))
  end
  local data = curl.WriteBuffer()
  c:setopt("CURLOPT_FOLLOWLOCATION", 1)
  c:setopt("CURLOPT_WRITEDATA", curl.Null)
  c:setopt("CURLOPT_WRITEFUNCTION", data.callback())
  local res = c:perform()
  if res ~= curl.CURLE_OK then return false, c:strerror(res) end
  local pkginfos = json:decode(data.get())
  data:clear()
  if pkginfos.type == 'error' then return false, pkginfos.results end
  return pkginfos.results, pkginfos.resultcount
end
function aur.info(pkgs)
  local pkginfos,msg = aur.getinfo(pkgs)
  if not pkginfos then return false, msg end
  local aurpkgs,missing,v,_,pkg={},{}
  for _,v in ipairs(pkginfos) do
    aurpkgs[v.Name] = true
  end
  local f=string.format
  for _,v in ipairs(pkgs) do
    if not aurpkgs[v] then missing[#missing+1] = v end
  end
  
  for v=1,#missing do
    io.stderr:write(f("%s not in AUR\n",missing[v]))
  end

  for _,pkg in ipairs(pkginfos) do
    for _,v in ipairs(AURFIELDS) do
      if type(pkg[v]) == 'table' then
        print(infotable(v, pkg[v]))
      elseif pkg[v] then
        print(infotext(v, pkg[v]))
      end
    end
    print()
  end

end

function get_foreign_pkgs(a) 
    local dbs = a:get_syncdbs()
    local pkg = a:get_localdb():get_pkgcache()
    local fpkgs = {}
    while pkg ~= nil do
        local name = alpm.alpm_pkg_get_name(pkg.data)
        local db = dbs
        local foreign=true
        while db ~= nil do
            if alpm.alpm_db_get_pkg(db.data, name) ~= nil then
                foreign = false
                break
            end
            db = db:Next()
        end
        if foreign then fpkgs[#fpkgs+1] = alpm.Pkgref(pkg.data) end
        pkg = pkg:Next()
    end
    return fpkgs
end

--for k,v in ipairs(list:to_table()) do
function getname(a)
    if not a then return "" end
    a = alpm.Pkg.get_name(a)
    if not a then return "" end
    return ffi.string(a)
end
local pkgs={}
for k,v in ipairs(get_foreign_pkgs(pacman)) do
    pkgs[k] = alpm.String(v:get_name())
end


function aur.getupdates()
  local pkgs={}
  for k,v in ipairs(get_foreign_pkgs(pacman)) do
      pkgs[k] = alpm.String(v:get_name())
  end
  local pkginfos = aur.getinfo(pkgs)
  local localdb = pacman:get_localdb()
  local updates,oldver={},{}
  for _,v in ipairs(pkginfos) do
    local p = localdb:get_pkg(v.Name)
    if (p.vercmp(v.Version, p:get_version()) > 0) then
      updates[#updates+1] = v
      oldver[#oldver+1] = ffi.string(p:get_version())
    end
  end
  return updates, oldver
end

function aur.download(pkg)
  
end

u,o=aur.getupdates()
for i=1,#u do
  print(("%s %s -> %s"):format(u[i].Name, o[i], u[i].Version))
end

local help='lurm '..VERSION..[=[ 
(C) 2014 Andreas Bosch <code@progandy.de>
Usage: lurm [ -smdfi ] [ -t [ SEARCHTYPE ] ] SEARCH_OR_PACKAGE... 

]=]
print(help)

local res, opts, nonoptind = pcall(optparse, {
  s = {},
  d = {},
  f = {}
    }, arg)

for k,v in pairs{a=1,c=4,d=2} do

print(k,v)
end

s = alpm.find_satisfier(pacman:get_localdb():get_pkgcache(), "libgl")
print(ffi.string(s:get_name()))
s = alpm.find_dbs_satisfier(pacman, pacman:get_syncdbs(), "libgl")
print(ffi.string(s:get_name()))
print(s==nil)

function pkg_is_local(pkgcache, dep)
    return alpm.find_satisfier(pkgcache, dep) ~= nil
end

function pkg_is_sync(handle, dblist, dep)
    return alpm.find_satisfier(handle, dblist, dep) ~= nil
end
--print(json:encode_pretty(json:decode(data.get())))
--print(archive.archive_version_number())
--print(ffi.string(archive.archive_version_string()))
--[[

resolve deps:

1: fetch AUR (multiinfo)
3: find missing (fetched + local + sync)
4: fetch missing (multiinfo)
5: find missing (fetched + local + sync)
6: if missing goto 4
7: topo deps

8: sort depends in install, tempinstall, aur, aur tempinstall

9: install depends
10: tempinstall depends
11: loop through makepkg, 
    prepare commands with split packages and asdepends switches
12: remove tempinstall depends
13: remove aur tempinstall
]]
--: vim: set ts=2 sw=2 tw=80 et :--
