#!/usr/bin/env luajit
local VERSION = "v0.1"
package.path = "./lib/?.lua;?.lua;" .. package.path
local ffi=require("ffi")
local alpm=require("alpm")
local archive=require("archive")
local json=require("JSON")
local curl=require("curl")


local enum = {}
function enum.bor(a, b)
    return ffi.cast(ffi.typeof(a), 
      bit.bor(tonumber(a),tonumber(ffi.cast(ffi.typeof(a), b))))
end
function enum.band(a, b)
    return ffi.cast(ffi.typeof(a), 
      bit.band(tonumber(a), tonumber(ffi.cast(ffi.typeof(a), b))))
end
function enum.hasset(a, b)
    return enum.band(a, b) == b
end

function table.set(t) -- set of list
  local u = { }
  for _, v in ipairs(t) do u[v] = true end
  return u
end

function table.add(f, l)
  assert(l ~= nil)
  if type(f) ~= 'table' then return {l} end
  for _, v in ipairs(f) do
    if v == l then return f end
  end
  f[#f+1] = l
  return f
end

pkgdata={}
local BaseTree = {}
BaseTree.__index = BaseTree
function BaseTree.new(t)
   t = t or {}
   return setmetatable(t, BaseTree)
end
setmetatable(BaseTree,{
    __call = function (tbl,arg)
       return tbl.new(arg)
    end,
})
function BaseTree:add(pkg)
    if self[pkg.PackageBase] == nil then self[pkg.PackageBase] = {} end
    table.add(self[pkg.PackageBase], pkg.Name)
end
x = BaseTree()
x:add({PackageBase="himo", Name="himo-gtk"})
x:add({PackageBase="himo", Name="himo-cli"})
print(x["himo"][1])

dbs = {}
for l in io.lines("/etc/pacman.conf") do
    local s = l:match("^%s*%[%s*([^%]%s]*)%s*]%s*$")
    if s and s ~= 'options' then
        dbs[#dbs+1] = s
    end
end
errno=ffi.new("alpm_errno_t[1]")
--pacman=ffi.gc(alpm.alpm_initialize('/', '/var/lib/pacman', errno), alpm.alpm_release)
pacman=alpm.Alpm.initialize('/', '/var/lib/pacman', errno)
for i,db in ipairs(dbs) do
    dbs[i] = alpm.alpm_register_syncdb(pacman, db,
                                        alpm.ALPM_SIG_DATABASE_OPTIONAL)
end


function get_foreign_pkgs(a) 
    local dbs = a:get_syncdbs()
    local pkg = a:get_localdb():get_pkgcache()
    local fpkgs = {}
    while pkg ~= nil do
        local name = alpm.alpm_pkg_get_name(pkg.data)
        local db = dbs
        local foreign=true
        while db ~= nil do
            if alpm.alpm_db_get_pkg(db.data, name) ~= nil then
                foreign = false
                break
            end
            db = db:Next()
        end
        if foreign then fpkgs[#fpkgs+1] = alpm.Pkgref(pkg.data) end
        pkg = pkg:Next()
    end
    return fpkgs
end

--for k,v in ipairs(list:to_table()) do
function getname(a)
    if not a then return "" end
    a = alpm.Pkg.get_name(a)
    if not a then return "" end
    return ffi.string(a)
end
--[[
for i,db in ipairs(dbs) do
    list = alpm.alpm_db_get_pkgcache(db)
    print("###", ffi.string(db:get_name()))
    for k,v in list:iter(getname) do
        print(k, v)
    end
    list=nil
end
]]
    function Set (list)
      local set = {}
      for _, l in ipairs(list) do set[l] = true end
      return set
    end
print(alpm.capabilities())
pkgs={}
for k,v in ipairs(get_foreign_pkgs(pacman)) do
    pkgs[k] = alpm.String(v:get_name())
end

p=table.concat(pkgs, "&arg[]=")
curl.init(curl.CURL_GLOBAL_ALL)
c = curl.Easy.init()
data = curl.WriteBuffer()
c:setopt("CURLOPT_URL", 
    "http://aur.archlinux.org/rpc.php?type=multiinfo&v=3&arg[]="..p)
--c:setopt("CURLOPT_URL", "http://aur.archlinux.org/rpc.php?type=multiinfo&v=3&arg[]=libindicator-gtk2&arg[]=cower")
--c:setopt("CURLOPT_URL","http://example.com")
c:setopt("CURLOPT_FOLLOWLOCATION", 1)
c:setopt("CURLOPT_WRITEDATA", curl.Null)
c:setopt("CURLOPT_WRITEFUNCTION", data.callback())
print(c:strerror(c:perform()))

aurpkgs = json:decode(data.get())
data.clear()
aurnames={}
for k,v in ipairs(aurpkgs.results) do
    aurnames[k] = v.Name
end
found = Set(aurnames)
for _,v in pairs(pkgs) do
    if not found[v] then print("#Missing", v) end
end

local help='lurm '..VERSION..[=[ 
(C) 2014 Andreas Bosch <code@progandy.de>
Usage: lurm [ -smdfi ] [ -t [ SEARCHTYPE ] ] SEARCH_OR_PACKAGE... 

]=]
print(help)

local res, opts, nonoptind = pcall(optparse, {
  s = {},
  d = {},
  f = {}
    }, arg)

for k,v in pairs{a=1,c=4,d=2} do

print(k,v)
end

s = alpm.find_satisfier(pacman:get_localdb():get_pkgcache(), "libgl")
print(ffi.string(s:get_name()))
s = alpm.find_dbs_satisfier(pacman, pacman:get_syncdbs(), "libgl")
print(ffi.string(s:get_name()))
print(s==nil)

function pkg_is_local(pkgcache, dep)
    return alpm.find_satisfier(pkgcache, dep) ~= nil
end

function pkg_is_sync(handle, dblist, dep)
    return alpm.find_satisfier(handle, dblist, dep) ~= nil
end
--print(json:encode_pretty(json:decode(data.get())))
--print(archive.archive_version_number())
--print(ffi.string(archive.archive_version_string()))
--[[

resolve deps:

1: fetch AUR (multiinfo)
3: find missing (fetched + local + sync)
4: fetch missing (multiinfo)
5: find missing (fetched + local + sync)
6: if missing goto 4
7: topo deps

8: sort depends in install, tempinstall, aur, aur tempinstall

9: install depends
10: tempinstall depends
11: loop through makepkg, 
    prepare commands with split packages and asdepends switches
12: remove tempinstall depends
13: remove aur tempinstall
]]
--: vim: set ts=2 sw=2 tw=80 et :--
